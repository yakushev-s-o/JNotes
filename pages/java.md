##### [<-- back to README](/README.md)

## Java

### Общее

#### JDK, JRE и JVM


* JDK (Java Development Kit) - набор программ для разработки. Включает в себя JRE, загрузчик кода java, компилятор javac, архиватор jar, генератор документации javadoc и другие утилиты.
* JRE (Java Runtime Environment) - окружение, необходимое для запуска Java-программ. Включает в себя JVM, стандартную библиотеку (пакеты lang, util, пакеты для работы с различными форматами, базами данных, пользовательским интерфейсом и другие пакеты).
* JVM (Java Virtual Machine) - виртуальная машина отвечает за выполнение байт-кода Java (.class).

#### Сборка, исполнение и архивация


Компиляция кода:

`javac HelloWorld.java`

* На выходе получаем файл HelloWorld.class

Запуск HelloWorld.class:

`java -cp . HelloWorld`  
 * Ключ `-cp` сокращение от `-classpath` указывает компилятору, где искать исходные файлы.

Компиляция кода с созданием каталогов:

`javac -d bin src/HelloWorld.java`  

На выходе получаем каталоги:  
* Исходный файл - `src/HelloWorld.java`  
* Скомпилированный файл - `bin/HelloWorld.class`

Запуск bin/HelloWorld.class из каталога:

`java -cp ./bin HelloWorld`

Архивация файлов (JAR - Java Archive):

`jar -cf jar-файл входной-файл(ы)`  
* Ключ `c` показывает, что необходимо создать (create) JAR-файл.
* Ключ `f` показывает, что необходимо направить вывод в файл, а не в стандартный поток вывода.
* `jar-файл` - название выходного JAR-файла с расширением `.jar`
* `входной-файл(ы)` - список файлов через пробел, которые необходимо поместить в JAR-файл.
* Команда `jar` автоматически создает файл `MANIFEST.MF` и помещает в каталог `META-INF`

Кроме JAR, также существуют другие архивы, связанные с Java:

* WAR (**W**eb **A**pplication A**r**chive) - содержит в себе приложение для веба.
* EAR (**E**nterprise **A**pplication A**r**chive) - содержит в себе энтерпрайз приложение (обычно из нескольких модулей).
* APK (**A**ndroid A**p**plication Pac**k**age) - содержит в себе приложение для Android.

#### Ключевые слова Java

Список ключевых слов:

* Примитивные типы: `byte`,`short`,`int`,`long`,`float`,`double`,`char`,`boolean`
* Управление потоком: `if`,`else`,`for`,`do`,`while`,`switch`,`case`,`default`,`break`,`continue`,`return`
* Обработка исключений: `try`,`catch`,`finally`,`throw`,`throws`,`assert`
* Модификаторы: `public`,`private`,`protected`,`final`,`static`,`native`,`abstract`,`synchronized`,`transient`,`volatile`,`strictfp`
* Связанные с классом: `class`,`interface`,`package`,`extends`,`implements`,`import`
* Связанный с объектом: `new`,`instanceof`,`super`,`this`
* Литералы: `true`,`false`,`null`
* Другие: `void`,`enum`
* Не используется: `goto`,`const`

### Типы данных

В Java доступны два типа данных:

* Примитивные типы данных (byte, short, char, int, long, float, double, boolean)
* Ссылочные типы данных (String, ...)



#### Целочисленные типы

Тип|Описание|Размер (бит)|Диапазон|По умолчанию
:---:|---|:---:|---|:---:
byte | Наименьшие целые числа | 8 бит | от -128 до 127 | 0
short | Короткие целые числа | 16 бит | от -32768 до 32767 | 0
char | Символы | 16 бит | беззнаковое целое число, символ UTF-16 (буквы и цифры) | \u0000
int | Целые числа | 32 бит | от -2147483648 до 2147483647 | 0
long | Длинные дробные числа | 64 бит | от -9223372036854775808L до 9223372036854775807L | 0L

Литералы:

* Десятичное число (_Decimal_): `123`
* Восьмеричное число (_Octal_): `0123`
* Шестнадцатеричное число (_Hex_): `0x123`
* Двоичное число (_Binary_): `0b101` (с Java 7)
* С подчеркиванием: `123_456_789` (с Java 7)
* С суффиксом L для long: `123456789L`

Класс-обертка для byte, short, int, long:

* MIN_VALUE
* MAX_VALUE
* toString(typename)
* parseTypename(String)
* bitCount(typename)
* reverse(typename)
* reverseBytes(typename)

#### Char (Unicode)

Литераллы:
* символы в одинарных кавычках: `'a'`
* шеснадцатиричный код символа: `'\u78bc'`

Управляющие последовательности (escape-последовательности):

Оператор|Описание
:---:|---
\t | Символ табуляции.
\b | Символ возврата в тексте на один шаг назад или удаление одного символа в строке (backspace).
\n | Символ перехода на новую строку.
\r | Символ возврата каретки.
\f | Прогон страницы.
\\' | Символ одинарной кавычки.
\\" | Символ двойной кавычки.
\\\ | Символ обратной косой черты (\\).
\\ddd | Восьмеричный символ (ddd)
\\uxxxx | Шестнадцатеричный символ UNICODE (xxxx)

Класс-обертка для char:

* char toLowerCase(char)
* char toUpperCase(char)
* boolean isLowerCase(char)
* boolean isUpperCase(char)
* boolean isDigit(char)
* boolean isLetter(char)
* boolean isHighSurrogate(char)
* boolean isLowSurrogate(char)

Некоторые символы представляются двумя char'ами - суррогатной парой.

Таблица ASCII:

![tableAscii](/img/tableAscii.jpg)

![ascii](/img/ascii.png)

#### Типы с плавающей точкой

Тип|Описание|Размер (бит)|Диапазон|По умолчанию
:---:|---|:---:|---|:---:
float | Длинные дробные числа | 32 бит | от 1.4e-45f до 3.4e+38f | 0,0f
double | Дробные числа двойной точности | 64 бит | от 4.9e-324 до 1.7e+308 | 0,0d

* Стандарт [IEEE754](https://ru.wikipedia.org/wiki/IEEE_754-2008)
* Побитовые операции не поддерживаются.

Литералы:

* Обычная запись: `-1.234`
* Экспоненциальная запись: `-123.4e-2` (−123.4 * 10−2)
* Шестнадцатеричная запись: `0xFFFFpFF` (FFFF * 2 FF)
* С суффиксом типа: `38f`, `3e19d`, `123.4e-2f`, `444.444d`

Особые случаи:

* Деление положительного числа на 0 дает +∞
* Деление отрицательного числа на 0 дает −∞
* Деление 0 на 0 дает NaN
* Переполнение дает +∞ или −∞, в зависимости от направления.
* NaN != NaN

strictfp:

* Java использует FPU для вычислений с плавающей точкой, но регистры  FPU могут быть шире 64 бит, в результате вычисления могут отличаться.
* Модификатор strictfp включает режим строгой совместимости, результаты будут идентичны на любом процессоре.

Класс-обертка для float, double:

* MIN_VALUE
* MAX_VALUE
* POSITIVE_INFINITY
* NEGATIVE_INFINITY
* NaN
* boolean isNaN(typename)
* toString(typename)
* parseTypename(String)

#### Логический тип

Тип|Описание|Размер (бит)|Диапазон
:---:|---|:---:|---
boolean	| Булевы выражения | 8 (в массивах) / 32 (не в массивах) | true (истина) или false (ложь)

#### Ссылочные

* Наследуют `java.lang.Object`
* Ссылка может принимать значение `null`

#### String

java.lang.String

* Класс реализует интерфейсы Serializable и CharSequence.
* Поскольку он входит в пакет java.lang, его не нужно импортировать.
* Класс String в Java — это final класс, который не может иметь потомков.
* Класс String — immutable класс, то есть его объекты не могут быть изменены после создания.
* Любые операции над объектом String, результатом которых должен быть объект класса String, приведут к созданию нового объекта.
* Благодаря своей неизменности, объекты класса String являются потокобезопасными и могут быть использованы в многопоточной среде.
* Каждый объект в Java может быть преобразован в строку через метод toString, унаследованный всеми Java-классами от класса Object.
* Строка — это не char[], хотя есть способы конвертации.
* Никаких нулевых символов в конце, длина хранится отдельно.

Строковые литералы:

```java
String zeros = "\u0000 \u0000";
String hello = "Hello";
String specialChars = "\r \n \t \" \\";
String unicodeEscapes = "\u0101 \u2134 \u03ff";
```

Создание из массива символов с помощью конструктора:

```java
char[] charArray = {’a’, ’b’, ’c’, ’d’};
String string = new String (charArray); // abcd
String string = new String (charArray, 0, 2); // ab
```

Доступ к содержимому строки:

```java
int length()
char charAt(int index)
char[] toCharArray()
String substring(int beginIndex)
String substring(int beginIndex, int endIndex)
```

Конкатенация строк:

```java
String helloWorld = "Hello " + "World!"; // Hello World!
```

java.lang.StringBuilder:

```java
StringBuilder buf = new StringBuilder();
buf.append ("Hello ");
buf.append ("World!");
String result = buf.toString(); // Hello World!
```

Сравнение строк:

* Оператор `==` сравнивает ссылки, а не содержимое строки.

```java
boolean equals(Object name)
boolean equalsIgnoreCase(String name)
int compareTo(String name)
int compareToIgnoreCase(String name)
```

#### Arrays

* Массив обозначается квадратными скобками.

```java
int[] first;
int []first;
int first[];
int[] first, second;
```

Создание:

* Массив создается оператором `new`
* Все элементы массива инициализируются нулями.
* Размер массива фиксируется в момент создания.

```java
int[] numbers = new int[100];
String[] args = new String[1];
boolean[] bits = new boolean[0];
```

Инициализация:

* Можно перечислить значения всех элементов при создании массива.

```java
int[] numbers = new int[] {1, 2, 3, 4, 5};
boolean[] bits = new boolean[] {true, true, false};
char[] digits = {1, 2, 3, 4, 5}; // Работает только в объявлении переменной
int[] arr; arr = {123}; // Error: Array initializer is not allowed here
```

Индексация:

* Элементы индексируются с нуля.
* Длина массива доступна как `array.length`
* При выходе за границы массива бросается исключение `ArrayIndexOutOfBoundsException`

Многомерные массивы:

* Многомерный массив — это массив массивов.

```java
int[][] multi;
int [][]multi;
int[] multi[];
int[][] multi = new int[2][2];
int[] multi[] = new int[][] {{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}} // new int[3][4]
int[][] matrix = {{1, 2}, {3, 4}}; // matrix2[1][1] -> 4
int[] row = matrix[0]; // row[0] -> 1
```

* Разрешены ступенчатые массивы.

```java
int[][] triangle = {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9},
        {10, 11, 12},
        {13, 14},
        {15}};
// triangle.length -> 5
// triangle[0].length -> 5
// triangle[4].length -> 1
```

Представление в памяти:

* Одномерный массив занимает непрерывный участок памяти.
* Двумерный массив занимает n + 1 участок в памяти, где n — первая размерность.

```java
int[][] a = new int[10][1000];
int[][] b = new int[1000][10];
```

VarArgs (Список переменных аргументов):

* Специальный синтаксис для массива аргументов (Поддерживается с Java 5).
* Аргумент VarArgs должен стоять последним в списке аргументов, перед ним сколько угодно.

```java
int max(int... num); // max(1, 2, 3, 4);
int min(String s, int... num) // min("Numbers", 1, 2, 3, 4)
```

Сравнение массивов:

* Сравнивает ссылки: `a == b`
* Сравнивает ссылки: `a.equals(b)`
* Сравнивает содержимое: `Arrays.equals(a, b)`
* Сравнивает содержимое многомерных массивов: `Arrays.deepEquals(a, b)`

Распечатка массива:

* Выводит название класса и хешкод "[I@2ce83912": `System.out.println(a)`
* Выводит содержимое: `System.out.println(Arrays.toString(a))`
* Выводит содержимое многомерных массивов: `System.out.println(Arrays.deepToString(a))`

java.util.Arrays:

* copyOf, copyOfRange
* fill
* sort
* binarySearch
* java.lang.System.arraycopy

#### Классы-оболочки

Тип|Класс-обертка|Путь
:---:|:---:|:---:
byte | Byte | java.lang.Byte
short | Short | java.lang.Short
int | Integer | java.lang.Short
long | Long | java.lang.Long
char | Character | java.lang.Integer
float | Float | java.lang.Float
double | Double | java.lang.Double
boolean | Boolean | java.lang.Boolean

* Все оболочки числовых типов наследуют абстрактный класс Number.
* Объекты классов-оберток являются неизменяемыми (Immutable).
* Переменной класса-обертки можно присваивать значение примитивного типа - автоупаковка (autoboxing).
* Переменной примитивного типа можно присваивать объект класса-обертки - автораспаковка (autounboxing).
* Автоупаковка и распаковка не работают для массивов.

Служебные методы:

`valueOf()` – возвращает соответствующий числовой объект, содержащий значение переданного аргумента.

```java
Integer a = Integer.valueOf(9); // 9
Double b = Double.valueOf(5); // 5.0
Float c = Float.valueOf("80"); // 80.0
Integer d = Integer.valueOf("444", 16); // 1092
```

`xxxValue()` - преобразует значение объекта Number, который вызывает метод, в примитивный тип данных, возвращаемый методом.

```java
Integer x = 5;
x.byteValue(); // 5
x.doubleValue(); // 5.0
x.longValue(); // 5L
```

`parseXxx()` - используется для получения примитивного типа данных определенной строки. Является статическим методом и может иметь один или два аргумента.

```java
int x = Integer.parseInt("9"); // 9
double c = Double.parseDouble("5"); // 5.0
int b = Integer.parseInt("444", 16); // 1092
```

`toString()` - используется для получения объекта String, представляющего значение объекта Number. Если метод принимает примитивный тип данных в качестве аргумента, то возвращается объект String, представляющий значение примитивного типа данных. Если метод принимает два аргумента, будет возвращено строковое представление первого аргумента в системе счисления, заданной вторым аргументом.

```java
Integer x = 5;
x.toString(); // "5"
Integer.toString(12); // "12"
```

`toXxxxString()` - возвращает строковое представление целочисленного аргумента в виде целого числа без знака в Binary/Octal/Hex формате.

```java
int i = 5;
Integer.toBinaryString(i) // 10101010
Integer.toOctalString(i)// 252
Integer.toHexString(i) // aa
```

#### Приведение типов

![cast](/img/cast.png)

Автоматические преобразования (с потерей точности):  
int --> float, long --> float и long --> double

```java
int a = 2147483647;
float b = a; // от типа int к типу float
System.out.println(b); // 2.14748365E9
```

Явные преобразования (с потерей точности):

```java
int a = 258;
byte b = (byte) a;
System.out.println(b); // 2
```

#### Арифметические операции

Оператор|Описание
:---:|---
\+ | сложение
\- | вычитание
\* | умножение
/ | деление целочисленное
% | остаток / деление по модулю `9 % 4 = 1`
\+= | сложение с присваиванием
\-= | вычитание с присваиванием
\*= | умножение с присваиванием
/= | деление с присваиванием
%= | деление по модулю с присваиванием
\++ | инкремент
\-- | декремент

* Деление на ноль — выбрасывается исключение `ArithmeticException`
* Переполнение не является исключением, лишние старшие биты выкидываются.

#### Оператор инкремент / декремент

* Оператор предварительного приращения возвращает значение после приращения. Оператор постинкремента возвращает значение до инкремента.

```java
int i = 25;
int j = ++i; // i увеличивается до 26, присваивается j
System.out.println(i + " " + j); //26 26
        
i = 25;
j = i++; // i значение (25) присваивается j, затем увеличивается до 26
System.out.println(i + " " + j); // 26 25
```

```java
i = 25;
j = --i; // i уменьшается до 24, присваивается j
System.out.println(i + " " + j);//24 24

i = 25;
j = i--; // i значение (25) присваивается j, затем уменьшается до 24
System.out.println(i + " " + j); // 24 25
```

### Math

java.lang.Math

* константы: E, PI
* тригонометрия: sin, cos
* степени: sqrt, pow, exp
* min, max

### Побитовые операции

Оператор | Описание
:---:|---
~ | Побитовый унарный оператор NOT
& | Побитовый AND
&= | Побитовый AND с присваиванием
&#124; | Побитовый OR
&#124;= | Побитовый OR с присваиванием
^ | Побитовый исключающее OR
^= | Побитовый исключающее OR с присваиванием
\>> | Сдвиг вправо
\>>= | Сдвиг вправо с присваиванием
\>>> | Сдвиг вправо с заполнением нулями
<< | Сдвиг влево
<<= | Сдвиг влево с присваиванием
\>>>= | Сдвиг вправо с заполнением нулями с присваиванием

`>>` - арифметический сдвиг  
`>>>` - логический сдвиг

A | B | A &#124; B | A & B | A ^ B | ~A
:---:|:---:|:---:|:---:|:---:|:---:
0 | 0 | 0 | 0 | 0 | 1
1 | 0 | 1 | 0 | 1 | 0
0 | 1 | 1 | 0 | 1 | 1
1 | 1 | 1 | 1 | 0 | 0

### Операторы сравнения (логические)

Оператор | Пример использования | Возвращает значение "true", если...
:---:|:---:|---
\> | a > b | а больше b
\>= | a >= b | а больше или равно b
< | a < b | а меньше b
<= | a <= b | а меньше или равно b
== | a == b | а равно b
!= | a != b | а не равно b
&& | a && b | а и b истинны, b оценивается условно (если а ложно, b не вычисляется)
&#124; &#124; | a &#124; &#124; b | а или b истинно, b оценивается условно (если а истинно, b не вычисляется)
! | !a | а ложно
& | a & b | а и b истинны, b оценивается в любом случае
&#124; | a &#124; b | а или b истинно, b оценивается в любом случае
^ | a ^ b | а и b различны

### Приоритет операторов

Оператор | Описание | Ассоциативность
:---:|:---:|:---:
++, — | постинкремент, постдекремент | справа налево
++, —, +, -, ~, ! | преинкремент, предекремент, унарный плюс, унарный минус, поразрядное дополнение, булево «не» | справа налево
*, /, % | умножение, деление, остаток от деления | слева направо
+, — | сложение, вычитание | слева направо
<<, >>, >>> | сдвиг влево, сдвиг вправо, беззнаковый сдвиг вправо | слева направо
<, >, \<=, >=, instanceof | меньше, больше, меньше или равно, больше или равно, сравнить тип | слева направо
==, != | равно, не равно | слева направо
& | битовое «и» | слева направо
^ | исключающее «или» | слева направо
&#124; | битовое «или» | слева направо
&& | логическое «и» | слева направо
&#124; &#124; | логическое «или» | слева направо
?: | тернарный оператор | слева направо
=, +=, -=,*=, /=, %=, &=, ^=, &#124; &#124;=, <<=, >>=, >>>= | операторы присваивания | справа налево

### Управляющие конструкции

#### Условный / тернарный оператор

`<логическое выражение> ? <выражение1> : <выражение2>`

```java
int a = 0;
System.out.println(a == 1 ? "One" : "Not one"); // Not one
```

#### Оператор instanceof

* Оператор проверяет, относится ли объект к определенному типу.
* Используется только для переменных ссылки на объект.

`<ссылочная переменная объекта> instanceof <тип класса/интерфейса>`

```java
String str = "String";
boolean res = str instanceof String; // true
Vehicle a = new Car();
boolean res =  a instanceof Car; // true
```

### Объектно-ориентированное программирование

* Объектно-ориентированное программирование — парадигма программирования, в которой программа строится из взаимодействующих объектов.

Объекты и классы:

* Класс - шаблонная конструкция позволяющая описать объект, его свойства (переменные или поля класса) и поведение (методы класса).
* Объект - экземпляр класса который имеет состояние и поведение. Например, у собаки есть состояние - цвет, имя, порода, а также поведение — виляет хвостом, лает, ест.

Создание объекта:

* Объявление - запись переменной с именем переменной и типом объекта.
* Создание экземпляра - создание объекта с помощью ключевого слова `new`
* Инициализация - за ключевым словом `new` следует вызов конструктора который инициализирует новый объект.

#### Типы переменных:

Локальные переменные:

* Переменные, определенные внутри методов, конструкторов или блоков.
* Переменная объявляется и инициализируется внутри метода и будет уничтожена, когда метод завершится.
* Модификаторы доступа нельзя использовать для локальных переменных.
* Локальные переменные видны только внутри объявленного метода, конструктора или блока.
* Локальные переменные реализованы на уровне стека.
* Локальные переменные не имеют значение по умолчанию, значение должно быть присвоено до использования.

```java
public class Test {
    public static void main(String[] args) {
        int first = 0;
        fisrt = fisrt + 7; // 7
        int second;
        // second = second + 7 // Error: variable number might not have been initialized
    }
}   
```

Переменные экземпляра:

* Переменные определяются внутри класса, но за пределами метода, конструктора или любого блока.
* Когда для объекта в куче выделяется место, создается слот для каждого значения переменной экземпляра.
* Переменные экземпляра создаются при создании объекта с использованием ключевого слова `new` и уничтожаются при уничтожении объекта.
* Модификаторы доступа могут быть заданы для переменных экземпляра.
* Доступ к переменным экземпляра можно получить из любого метода, конструктора или блока.
* Переменные экземпляра имеют значения по умолчанию. Для чисел значение по умолчанию равно 0, для логических значений — false, а для ссылок на объекты — null.
* Значения могут быть присвоены во время объявления или в конструкторе.
* Переменная экземпляра может быть вызвана напрямую через имя переменной внутри класса. В статичных методах их следует вызывать с иcпользованием полного имени `ObjectName.varName`

```java
public class Test {
    public int first; // Переменная экземпляра открыта для любого дочернего класса
    private int second; // Переменная экземпляра видна только в Test

    // Значение переменной first присваивается в конструкторе
    public Test(int num) {
        first = num;
    }
        
    // Значение переменной second присваивается в методе
    public void method (int num) {
        second = num;
    }

    public static void main(String[] args) {
        Test test = new Test(7);
        test.method(5);
    }
}   
```

Переменные класса (статические переменные):
* Объявляются внутри класса с ключевым словом static, вне любого метода, конструктора или блока.
* Статическая переменная, видна из всех экземпляров этого объекта, и ее значение не меняется от экземпляра к экземпляру, существует независимо от каких-либо экземпляров, поэтому оно принадлежит всему классу.
* Создается только одна копия каждой статической переменной в классе, независимо от того, сколько объектов создано из него.
* Статические переменные используются редко, кроме когда объявляются как константы. Константы - переменные, которые объявлены как public/private, final и static. Константы никогда не меняются от первоначального значения.
* Статические переменные создаются при запуске программы и уничтожаются при остановке программы.
* Статические переменные хранятся в "статической памяти" специальном пуле в памяти JVM, называемом Metaspace.
* Видимость похожа на переменные экземпляра. Однако большинство статических переменных объявляются общедоступными, поскольку они должны быть доступны для пользователей класса.
* Значения по умолчанию такое же, как и у переменных экземпляра. Для чисел по умолчанию равно 0, для данных типа boolean – false; и для ссылок на объект – null. Значения могут быть присвоены при объявлении или в конструкторе. Кроме того, они могут быть присвоены в специальных блоках статического инициализатора.
* Доступ к статическим переменным можно получить, вызвав имя класса `ClassName.varName`
* При объявлении переменных класса как `public static final` имена переменных (константы) пишутся в верхнем регистре.
* Если доступ к переменным осуществляется из внешнего класса, к константе следует обращаться как к `ClassName.CONSTANTA`

```java
public class Test {
    public static int first;
    static int second;
    public static final int TEST = 5; // Объявление статичной переменной (константа)

    public static void main(String[] args) {
        first = 7;
        Test.second = TEST; // 5
    }
}
```

#### Пакеты

* Пакеты позволяют объединить классы в группы, предотвращая конфликт с названиями имен, для контроля доступа, для облегчения поиска и использования классов, интерфейсов и аннотаций и т.д.
* Стандартные пакеты: java.lang, java.util, java.io и т.д

Создание пакета:

```java
package название_пакета;
```

Импорт пакетов и классов:

```java
import java.util.Scanner; // импорт класса Scanner
import java.util.*; // импорт всех классов из пакета java.util
```

Указание полного пути к файлу в пакете при создании объекта:

```java
java.util.Scanner in = new java.util.Scanner(System.in);
```

Статический импорт:

* При статическом импорте можно использовать методы без вызова его класса:

```java
import static java.lang.Math.*; // импорт статического класса Math
sqrt(20); // Вместо `Math.sqrt(20)`
```

#### Типы модификаторов

Модификаторы контроля доступа:

`public`

Публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.

`protected`

Такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах.

`default (package-private)`

Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

`private`

Закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.

Модификатор|Класс|Пакет|Наследники|Внешние классы
---|:---:|:---:|:---:|:---:
public | + | + | + |+
protected | + | + | + | -
default | + | + | - | -
private | + | - | - | -

Правила контроля доступа и наследования:

* Методы объявленные как public в суперклассе, также должны быть public во всех подклассах.
* Методы объявленные как protected в суперклассе, должны быть protected, либо public в подклассах (они не могут быть private).
* Методы объявленные как private не наследуются.

Модификаторы класса, метода, переменной и потока, используемые не для доступа:

* Модификатор `static` применяется для создания методов и переменных класса.
* Модификатор `final` используется для завершения реализации классов, методов и переменных.
* Модификатор `abstract` необходим для создания абстрактных классов и методов.
* Модификаторы `synchronized` и `volatile` используются в Java для потоков.

### Исключения

![exceptions1](/img/exceptions1.png)

![exceptions2](/img/exceptions2.png)

### Коллекции

![collections](/img/collections.png)

### Приемы и хитрости

#### Замер скорости компиляции

```java
long nTime = System.nanoTime(); // Start
// Код
System.out.printf("Time -> %,1.3f ms\n", (System.nanoTime() - nTime)/1_000_000.0); // Stop
// System.out.println("Fast version: " + (double) fastVersion / 1000000000 + " s");
```
### Примеры

Fibonacci

```java
public class Fibonacci {
  public static long getFibonacciNumber(int n) {
    if (n <= 0) {
      return 0;
    }
    long prev = 0;
    long curr = 1;
    for (int i = 1; i < n; ++i) {
      long next = prev + curr;
      prev = curr;
      curr = next;
    }
    return curr;
  }

  public static void printFibonacci(int max) {
    for (int i = 0; i <= max; ++i) {
      System.out.printf("fib (%d) = %d\n", i, getFibonacciNumber(i));
    }
  }

  public static void main(String[] args) {
    printFibonacci(15);
  }
}
```

FibonacciBigInteger

```java
import java.math.BigInteger;

public class FibonacciBigInteger {
  public static BigInteger getFibonacciNumber(int n) {
    if (n <= 0) {
      return BigInteger.ZERO;
    }
    BigInteger prev = BigInteger.ZERO;
    BigInteger curr = BigInteger.ONE;
    for (int i = 1; i < n; ++i) {
      BigInteger next = prev.add(curr);
      prev = curr;
      curr = next;
    }
    return curr;
  }

  public static void printFibonacciBigInteger(int max) {
    for (int i = 0; i <= max; ++i) {
      System.out.printf("fib (%d) = %d\n", i, getFibonacciNumber(i));
    }
  }

  public static void main(String[] args) {
    printFibonacciBigInteger(15);
  }
}
```

Anagrams

```java
import java.util.Arrays;

public class Anagrams {
  public static boolean areAnagrams(String a, String b) {
    char[] charsFromA = getSortedChars(a);
    char[] charsFromB = getSortedChars(b);
    return Arrays.equals(charsFromA, charsFromB);
  }

  private static char[] getSortedChars(String s) {
    char[] chars = s.toCharArray();
    Arrays.sort(chars);
    return chars;
  }

  public static void printAnagrams(String a, String b) {
    System.out.println(areAnagrams(a, b) ? "anagrams" : "not anagrams");
  }

  public static void main(String[] args) {
    printAnagrams("silent", "listen");
  }
}
```

Palindromes

```java
public class Palindromes {
  public static boolean isPalindrome(String s) {
    String normalizedText = normalize(s);
    return normalizedText.equals(reverse(normalizedText));
  }

  private static String normalize(String s) {
    return s.toLowerCase().replaceAll("\\W+", "");
  }

  private static String reverse(String s) {
    return new StringBuilder(s).reverse().toString();
  }

  public static void printPalindromes(String s) {
    System.out.println(isPalindrome(s) ? "palindrome" : "not palindrome");
  }

  public static void main(String[] args) {
    printPalindromes("Madam, I’m Adam");
  }
}
```

Polygons

```java
public class Polygons {
  public static double getArea(double[][] polygon) {
    int size = polygon.length;
    double sum = 0;
    for (int i = 0; i < size; ++i) {
      int j = (i + 1) % size;
      sum += det(polygon[i][0], polygon[i][1], polygon[j][0], polygon[j][1]);
    }
    return Math.abs(sum / 2);
  }

  private static double det(double x1, double y1, double x2, double y2) {
    return x1 * y2 - x2 * y1;
  }

  public static void main(String[] args) {
    double[][] polygon = new double[][]{{1, 1}, {1, 2}, {2, 2}, {2, 1}};
    System.out.printf("Polygon area = %1.3f\n", getArea(polygon));
  }
}
```